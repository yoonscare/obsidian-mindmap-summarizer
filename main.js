/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => MindmapSummarizerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  selectedProvider: "gemini",
  openaiApiKey: "",
  openaiModel: "gpt-4o-mini",
  anthropicApiKey: "",
  anthropicModel: "claude-3-5-sonnet-20241022",
  geminiApiKey: "",
  geminiModel: "gemini-2.0-flash",
  grokApiKey: "",
  grokModel: "grok-2-latest",
  language: "Korean",
  maxTokens: 2048
};
var AVAILABLE_MODELS = {
  openai: ["gpt-4o", "gpt-4o-mini", "gpt-4-turbo", "gpt-3.5-turbo"],
  anthropic: ["claude-3-5-sonnet-20241022", "claude-3-5-haiku-20241022", "claude-3-opus-20240229"],
  gemini: ["gemini-2.0-flash", "gemini-2.5-flash-preview-05-20", "gemini-2.5-pro-preview-06-05", "gemini-2.5-flash-preview-image-05-20", "gemini-2.5-pro-preview-image-05-20", "gemini-1.5-pro", "gemini-1.5-flash"],
  grok: ["grok-2-latest", "grok-2", "grok-beta"]
};

// src/providers/openai.ts
var import_obsidian = require("obsidian");

// src/providers/base.ts
var MINDMAP_SYSTEM_PROMPT = `You are an expert at analyzing text and creating structured mindmaps.
Your task is to summarize the given text and create a hierarchical mindmap structure.

Rules:
1. Extract the main topic as the title
2. Identify 3-7 main themes/categories
3. Each main theme should have 2-5 sub-points
4. Keep each node text concise (under 50 characters)
5. Maintain logical hierarchy and relationships
6. Focus on key concepts, not details

Output format (JSON):
{
  "title": "Main Topic",
  "nodes": [
    {
      "text": "Main Theme 1",
      "children": [
        { "text": "Sub-point 1.1" },
        { "text": "Sub-point 1.2" }
      ]
    },
    {
      "text": "Main Theme 2",
      "children": [
        { "text": "Sub-point 2.1" },
        { "text": "Sub-point 2.2" }
      ]
    }
  ]
}

IMPORTANT: Return ONLY valid JSON, no markdown formatting or additional text.`;
function createUserPrompt(text, language) {
  return `Please analyze the following text and create a mindmap summary in ${language}.

Text to analyze:
${text}

Remember: Return ONLY valid JSON.`;
}
function parseAIResponse(response) {
  let jsonStr = response.trim();
  const jsonMatch = jsonStr.match(/```(?:json)?\s*([\s\S]*?)```/);
  if (jsonMatch) {
    jsonStr = jsonMatch[1].trim();
  }
  const startIdx = jsonStr.indexOf("{");
  const endIdx = jsonStr.lastIndexOf("}");
  if (startIdx !== -1 && endIdx !== -1) {
    jsonStr = jsonStr.substring(startIdx, endIdx + 1);
  }
  const result = JSON.parse(jsonStr);
  if (!result.title || !result.nodes || !Array.isArray(result.nodes)) {
    throw new Error("Invalid mindmap structure in AI response");
  }
  return result;
}
var BaseProvider = class {
  validateConfig() {
  }
};

// src/providers/openai.ts
var OpenAIProvider = class extends BaseProvider {
  constructor(apiKey, model, maxTokens) {
    super();
    this.apiKey = apiKey;
    this.model = model;
    this.maxTokens = maxTokens;
    this.name = "OpenAI";
    this.type = "openai";
  }
  async summarize(text, language) {
    var _a, _b, _c;
    if (!this.apiKey) {
      throw new Error("OpenAI API key is not configured");
    }
    const response = await (0, import_obsidian.requestUrl)({
      url: "https://api.openai.com/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: this.model,
        messages: [
          { role: "system", content: MINDMAP_SYSTEM_PROMPT },
          { role: "user", content: createUserPrompt(text, language) }
        ],
        max_tokens: this.maxTokens,
        temperature: 0.7,
        response_format: { type: "json_object" }
      })
    });
    if (response.status !== 200) {
      throw new Error(`OpenAI API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const content = (_c = (_b = (_a = data.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content;
    if (!content) {
      throw new Error("No content in OpenAI response");
    }
    return parseAIResponse(content);
  }
};

// src/providers/anthropic.ts
var import_obsidian2 = require("obsidian");
var AnthropicProvider = class extends BaseProvider {
  constructor(apiKey, model, maxTokens) {
    super();
    this.apiKey = apiKey;
    this.model = model;
    this.maxTokens = maxTokens;
    this.name = "Anthropic Claude";
    this.type = "anthropic";
  }
  async summarize(text, language) {
    var _a, _b;
    if (!this.apiKey) {
      throw new Error("Anthropic API key is not configured");
    }
    const response = await (0, import_obsidian2.requestUrl)({
      url: "https://api.anthropic.com/v1/messages",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "x-api-key": this.apiKey,
        "anthropic-version": "2023-06-01"
      },
      body: JSON.stringify({
        model: this.model,
        max_tokens: this.maxTokens,
        system: MINDMAP_SYSTEM_PROMPT,
        messages: [
          { role: "user", content: createUserPrompt(text, language) }
        ]
      })
    });
    if (response.status !== 200) {
      throw new Error(`Anthropic API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const content = (_b = (_a = data.content) == null ? void 0 : _a[0]) == null ? void 0 : _b.text;
    if (!content) {
      throw new Error("No content in Anthropic response");
    }
    return parseAIResponse(content);
  }
};

// src/providers/gemini.ts
var import_obsidian3 = require("obsidian");
var GeminiProvider = class extends BaseProvider {
  constructor(apiKey, model, maxTokens) {
    super();
    this.apiKey = apiKey;
    this.model = model;
    this.maxTokens = maxTokens;
    this.name = "Google Gemini";
    this.type = "gemini";
  }
  async summarize(text, language) {
    var _a, _b, _c, _d, _e;
    if (!this.apiKey) {
      throw new Error("Gemini API key is not configured");
    }
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${this.model}:generateContent?key=${this.apiKey}`;
    const response = await (0, import_obsidian3.requestUrl)({
      url,
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        contents: [
          {
            parts: [
              { text: `${MINDMAP_SYSTEM_PROMPT}

${createUserPrompt(text, language)}` }
            ]
          }
        ],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: this.maxTokens,
          responseMimeType: "application/json"
        }
      })
    });
    if (response.status !== 200) {
      throw new Error(`Gemini API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const content = (_e = (_d = (_c = (_b = (_a = data.candidates) == null ? void 0 : _a[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts) == null ? void 0 : _d[0]) == null ? void 0 : _e.text;
    if (!content) {
      throw new Error("No content in Gemini response");
    }
    return parseAIResponse(content);
  }
};

// src/providers/grok.ts
var import_obsidian4 = require("obsidian");
var GrokProvider = class extends BaseProvider {
  constructor(apiKey, model, maxTokens) {
    super();
    this.apiKey = apiKey;
    this.model = model;
    this.maxTokens = maxTokens;
    this.name = "xAI Grok";
    this.type = "grok";
  }
  async summarize(text, language) {
    var _a, _b, _c;
    if (!this.apiKey) {
      throw new Error("Grok API key is not configured");
    }
    const response = await (0, import_obsidian4.requestUrl)({
      url: "https://api.x.ai/v1/chat/completions",
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${this.apiKey}`
      },
      body: JSON.stringify({
        model: this.model,
        messages: [
          { role: "system", content: MINDMAP_SYSTEM_PROMPT },
          { role: "user", content: createUserPrompt(text, language) }
        ],
        max_tokens: this.maxTokens,
        temperature: 0.7
      })
    });
    if (response.status !== 200) {
      throw new Error(`Grok API error: ${response.status} - ${response.text}`);
    }
    const data = response.json;
    const content = (_c = (_b = (_a = data.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) == null ? void 0 : _c.content;
    if (!content) {
      throw new Error("No content in Grok response");
    }
    return parseAIResponse(content);
  }
};

// src/providers/index.ts
function createProvider(settings) {
  const providerType = settings.selectedProvider;
  switch (providerType) {
    case "openai":
      return new OpenAIProvider(
        settings.openaiApiKey,
        settings.openaiModel,
        settings.maxTokens
      );
    case "anthropic":
      return new AnthropicProvider(
        settings.anthropicApiKey,
        settings.anthropicModel,
        settings.maxTokens
      );
    case "gemini":
      return new GeminiProvider(
        settings.geminiApiKey,
        settings.geminiModel,
        settings.maxTokens
      );
    case "grok":
      return new GrokProvider(
        settings.grokApiKey,
        settings.grokModel,
        settings.maxTokens
      );
    default:
      throw new Error(`Unknown provider type: ${providerType}`);
  }
}
function getProviderDisplayName(type) {
  const names = {
    openai: "OpenAI (GPT)",
    anthropic: "Anthropic (Claude)",
    gemini: "Google (Gemini)",
    grok: "xAI (Grok)"
  };
  return names[type];
}

// src/mindmap-generator.ts
var MindmapGenerator = class {
  /**
   * Convert SummarizeResult to Obsidian-compatible Mermaid mindmap format
   * With larger font size using %%{init}%% directive
   */
  generateMermaidMindmap(result) {
    const lines = [];
    lines.push("```mermaid");
    lines.push('%%{init: {"mindmap": {"fontSize": 18}}}%%');
    lines.push("mindmap");
    lines.push(`  root((${this.escapeText(result.title)}))`);
    for (const node of result.nodes) {
      this.addMermaidNode(lines, node, 2);
    }
    lines.push("```");
    return lines.join("\n");
  }
  addMermaidNode(lines, node, depth) {
    const indent = "  ".repeat(depth);
    lines.push(`${indent}${this.escapeText(node.text)}`);
    if (node.children) {
      for (const child of node.children) {
        this.addMermaidNode(lines, child, depth + 1);
      }
    }
  }
  /**
   * Convert SummarizeResult to Markdown bullet list format
   */
  generateMarkdownList(result) {
    const lines = [];
    lines.push(`# ${result.title}`);
    lines.push("");
    for (const node of result.nodes) {
      this.addMarkdownNode(lines, node, 0);
    }
    return lines.join("\n");
  }
  addMarkdownNode(lines, node, depth) {
    const indent = "  ".repeat(depth);
    const bullet = depth === 0 ? "##" : "-";
    if (depth === 0) {
      lines.push(`${bullet} ${node.text}`);
      lines.push("");
    } else {
      lines.push(`${indent}${bullet} ${node.text}`);
    }
    if (node.children) {
      for (const child of node.children) {
        this.addMarkdownNode(lines, child, depth + 1);
      }
    }
  }
  /**
   * Convert SummarizeResult to Canvas-compatible JSON format
   */
  generateCanvasJson(result) {
    const nodes = [];
    const edges = [];
    const rootId = this.generateId();
    nodes.push({
      id: rootId,
      type: "text",
      text: `# ${result.title}`,
      x: 0,
      y: 0,
      width: 300,
      height: 100,
      color: "1"
    });
    const childCount = result.nodes.length;
    const radius = 400;
    const angleStep = 2 * Math.PI / childCount;
    result.nodes.forEach((node, index) => {
      const angle = index * angleStep - Math.PI / 2;
      const x = Math.cos(angle) * radius;
      const y = Math.sin(angle) * radius;
      const nodeId = this.addCanvasNodes(nodes, edges, node, x, y, rootId);
    });
    return JSON.stringify({ nodes, edges }, null, 2);
  }
  addCanvasNodes(nodes, edges, node, x, y, parentId) {
    const nodeId = this.generateId();
    nodes.push({
      id: nodeId,
      type: "text",
      text: node.text,
      x,
      y,
      width: 250,
      height: 60,
      color: "4"
    });
    edges.push({
      id: this.generateId(),
      fromNode: parentId,
      fromSide: "bottom",
      toNode: nodeId,
      toSide: "top"
    });
    if (node.children) {
      const childCount = node.children.length;
      const spacing = 150;
      const startX = x - (childCount - 1) * spacing / 2;
      node.children.forEach((child, index) => {
        const childX = startX + index * spacing;
        const childY = y + 150;
        this.addCanvasNodes(nodes, edges, child, childX, childY, nodeId);
      });
    }
    return nodeId;
  }
  /**
   * Convert to Markmap format (compatible with obsidian-markmind plugin)
   */
  generateMarkmap(result) {
    const lines = [];
    lines.push("---");
    lines.push("markmap:");
    lines.push("  colorFreezeLevel: 2");
    lines.push("---");
    lines.push("");
    lines.push(`# ${result.title}`);
    lines.push("");
    for (const node of result.nodes) {
      this.addMarkmapNode(lines, node, 2);
    }
    return lines.join("\n");
  }
  addMarkmapNode(lines, node, headingLevel) {
    const prefix = "#".repeat(Math.min(headingLevel, 6));
    lines.push(`${prefix} ${node.text}`);
    if (node.children) {
      for (const child of node.children) {
        this.addMarkmapNode(lines, child, headingLevel + 1);
      }
    }
  }
  escapeText(text) {
    return text.replace(/\(/g, "\uFF3B").replace(/\)/g, "\uFF3D").replace(/"/g, "'").replace(/\n/g, " ");
  }
  generateId() {
    return Math.random().toString(36).substring(2, 15);
  }
};

// src/settings-tab.ts
var import_obsidian5 = require("obsidian");
var MindmapSummarizerSettingTab = class extends import_obsidian5.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h1", { text: "Mindmap Summarizer Settings" });
    containerEl.createEl("h2", { text: "AI Provider" });
    new import_obsidian5.Setting(containerEl).setName("Select AI Provider").setDesc("Choose which AI service to use for summarization").addDropdown((dropdown) => {
      const providers = ["openai", "anthropic", "gemini", "grok"];
      providers.forEach((provider) => {
        dropdown.addOption(provider, getProviderDisplayName(provider));
      });
      dropdown.setValue(this.plugin.settings.selectedProvider).onChange(async (value) => {
        this.plugin.settings.selectedProvider = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Output Language").setDesc("Language for the mindmap content").addDropdown((dropdown) => {
      dropdown.addOption("Korean", "\uD55C\uAD6D\uC5B4").addOption("English", "English").addOption("Japanese", "\u65E5\u672C\u8A9E").addOption("Chinese", "\u4E2D\u6587").setValue(this.plugin.settings.language).onChange(async (value) => {
        this.plugin.settings.language = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian5.Setting(containerEl).setName("Max Tokens").setDesc("Maximum number of tokens for AI response").addSlider((slider) => {
      slider.setLimits(512, 4096, 256).setValue(this.plugin.settings.maxTokens).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxTokens = value;
        await this.plugin.saveSettings();
      });
    });
    this.displayProviderSettings(containerEl);
  }
  displayProviderSettings(containerEl) {
    const provider = this.plugin.settings.selectedProvider;
    containerEl.createEl("h2", { text: `${getProviderDisplayName(provider)} Settings` });
    switch (provider) {
      case "openai":
        this.displayOpenAISettings(containerEl);
        break;
      case "anthropic":
        this.displayAnthropicSettings(containerEl);
        break;
      case "gemini":
        this.displayGeminiSettings(containerEl);
        break;
      case "grok":
        this.displayGrokSettings(containerEl);
        break;
    }
  }
  displayOpenAISettings(containerEl) {
    new import_obsidian5.Setting(containerEl).setName("API Key").setDesc("Your OpenAI API key").addText((text) => {
      text.setPlaceholder("sk-...").setValue(this.plugin.settings.openaiApiKey).onChange(async (value) => {
        this.plugin.settings.openaiApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian5.Setting(containerEl).setName("Model").setDesc("Select OpenAI model").addDropdown((dropdown) => {
      AVAILABLE_MODELS.openai.forEach((model) => {
        dropdown.addOption(model, model);
      });
      dropdown.setValue(this.plugin.settings.openaiModel).onChange(async (value) => {
        this.plugin.settings.openaiModel = value;
        await this.plugin.saveSettings();
      });
    });
    this.addApiKeyHelp(containerEl, "https://platform.openai.com/api-keys");
  }
  displayAnthropicSettings(containerEl) {
    new import_obsidian5.Setting(containerEl).setName("API Key").setDesc("Your Anthropic API key").addText((text) => {
      text.setPlaceholder("sk-ant-...").setValue(this.plugin.settings.anthropicApiKey).onChange(async (value) => {
        this.plugin.settings.anthropicApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian5.Setting(containerEl).setName("Model").setDesc("Select Anthropic Claude model").addDropdown((dropdown) => {
      AVAILABLE_MODELS.anthropic.forEach((model) => {
        dropdown.addOption(model, model);
      });
      dropdown.setValue(this.plugin.settings.anthropicModel).onChange(async (value) => {
        this.plugin.settings.anthropicModel = value;
        await this.plugin.saveSettings();
      });
    });
    this.addApiKeyHelp(containerEl, "https://console.anthropic.com/settings/keys");
  }
  displayGeminiSettings(containerEl) {
    new import_obsidian5.Setting(containerEl).setName("API Key").setDesc("Your Google AI Studio API key").addText((text) => {
      text.setPlaceholder("AIza...").setValue(this.plugin.settings.geminiApiKey).onChange(async (value) => {
        this.plugin.settings.geminiApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian5.Setting(containerEl).setName("Model").setDesc("Select Gemini model").addDropdown((dropdown) => {
      AVAILABLE_MODELS.gemini.forEach((model) => {
        dropdown.addOption(model, model);
      });
      dropdown.setValue(this.plugin.settings.geminiModel).onChange(async (value) => {
        this.plugin.settings.geminiModel = value;
        await this.plugin.saveSettings();
      });
    });
    this.addApiKeyHelp(containerEl, "https://aistudio.google.com/app/apikey");
  }
  displayGrokSettings(containerEl) {
    new import_obsidian5.Setting(containerEl).setName("API Key").setDesc("Your xAI API key").addText((text) => {
      text.setPlaceholder("xai-...").setValue(this.plugin.settings.grokApiKey).onChange(async (value) => {
        this.plugin.settings.grokApiKey = value;
        await this.plugin.saveSettings();
      });
      text.inputEl.type = "password";
    });
    new import_obsidian5.Setting(containerEl).setName("Model").setDesc("Select Grok model").addDropdown((dropdown) => {
      AVAILABLE_MODELS.grok.forEach((model) => {
        dropdown.addOption(model, model);
      });
      dropdown.setValue(this.plugin.settings.grokModel).onChange(async (value) => {
        this.plugin.settings.grokModel = value;
        await this.plugin.saveSettings();
      });
    });
    this.addApiKeyHelp(containerEl, "https://console.x.ai/");
  }
  addApiKeyHelp(containerEl, url) {
    const helpEl = containerEl.createEl("div", { cls: "setting-item-description" });
    helpEl.innerHTML = `Get your API key from: <a href="${url}">${url}</a>`;
  }
};

// src/input-modal.ts
var import_obsidian6 = require("obsidian");
var MindmapInputModal = class extends import_obsidian6.Modal {
  constructor(app, settings, sourceText, onSubmit) {
    super(app);
    // UI Components
    this.modelDropdown = null;
    this.settings = settings;
    this.sourceText = sourceText;
    this.onSubmit = onSubmit;
    this.selectedProvider = settings.selectedProvider;
    this.selectedModel = this.getCurrentModel(settings.selectedProvider);
    this.selectedLanguage = settings.language;
    this.selectedFormat = "mermaid";
    this.customPrompt = "";
  }
  getCurrentModel(provider) {
    switch (provider) {
      case "openai":
        return this.settings.openaiModel;
      case "anthropic":
        return this.settings.anthropicModel;
      case "gemini":
        return this.settings.geminiModel;
      case "grok":
        return this.settings.grokModel;
      default:
        return AVAILABLE_MODELS[provider][0];
    }
  }
  hasApiKey(provider) {
    switch (provider) {
      case "openai":
        return !!this.settings.openaiApiKey;
      case "anthropic":
        return !!this.settings.anthropicApiKey;
      case "gemini":
        return !!this.settings.geminiApiKey;
      case "grok":
        return !!this.settings.grokApiKey;
      default:
        return false;
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("mindmap-input-modal");
    contentEl.createEl("h2", { text: "Generate Mindmap" });
    const previewContainer = contentEl.createDiv({ cls: "mindmap-source-preview" });
    previewContainer.createEl("h4", { text: "Source Text Preview" });
    const previewText = this.sourceText.length > 500 ? this.sourceText.substring(0, 500) + "..." : this.sourceText;
    previewContainer.createEl("p", {
      text: previewText,
      cls: "mindmap-preview-text"
    });
    previewContainer.createEl("small", {
      text: `Total: ${this.sourceText.length} characters`,
      cls: "mindmap-char-count"
    });
    new import_obsidian6.Setting(contentEl).setName("AI Provider").setDesc("Select the AI service to use").addDropdown((dropdown) => {
      const providers = ["openai", "anthropic", "gemini", "grok"];
      providers.forEach((provider) => {
        const hasKey = this.hasApiKey(provider);
        const label = `${getProviderDisplayName(provider)}${hasKey ? "" : " (No API Key)"}`;
        dropdown.addOption(provider, label);
      });
      dropdown.setValue(this.selectedProvider).onChange((value) => {
        this.selectedProvider = value;
        this.selectedModel = this.getCurrentModel(value);
        this.updateModelDropdown();
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Model").setDesc("Select the specific model").addDropdown((dropdown) => {
      this.modelDropdown = dropdown;
      this.updateModelDropdown();
    });
    new import_obsidian6.Setting(contentEl).setName("Output Language").setDesc("Language for the mindmap content").addDropdown((dropdown) => {
      dropdown.addOption("Korean", "\uD55C\uAD6D\uC5B4").addOption("English", "English").addOption("Japanese", "\u65E5\u672C\u8A9E").addOption("Chinese", "\u4E2D\u6587").addOption("Spanish", "Espa\xF1ol").addOption("French", "Fran\xE7ais").addOption("German", "Deutsch").setValue(this.selectedLanguage).onChange((value) => {
        this.selectedLanguage = value;
      });
    });
    new import_obsidian6.Setting(contentEl).setName("Output Format").setDesc("Choose the mindmap format").addDropdown((dropdown) => {
      dropdown.addOption("mermaid", "Mermaid Diagram").addOption("markdown", "Markdown List").addOption("markmap", "Markmap Format").addOption("canvas", "Obsidian Canvas").setValue(this.selectedFormat).onChange((value) => {
        this.selectedFormat = value;
      });
    });
    const customPromptSetting = new import_obsidian6.Setting(contentEl).setName("Custom Instructions (Optional)").setDesc("Add specific instructions for the AI");
    const promptContainer = contentEl.createDiv({ cls: "mindmap-prompt-container" });
    const promptTextArea = new import_obsidian6.TextAreaComponent(promptContainer);
    promptTextArea.setPlaceholder("e.g., Focus on technical aspects, Include examples, Use simple language...").setValue(this.customPrompt).onChange((value) => {
      this.customPrompt = value;
    });
    promptTextArea.inputEl.rows = 3;
    promptTextArea.inputEl.addClass("mindmap-custom-prompt");
    const buttonContainer = contentEl.createDiv({ cls: "mindmap-button-container" });
    new import_obsidian6.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      this.close();
    });
    new import_obsidian6.ButtonComponent(buttonContainer).setButtonText("Generate Mindmap").setCta().onClick(() => {
      this.handleSubmit();
    });
  }
  updateModelDropdown() {
    if (!this.modelDropdown)
      return;
    this.modelDropdown.selectEl.empty();
    const models = AVAILABLE_MODELS[this.selectedProvider];
    models.forEach((model) => {
      this.modelDropdown.addOption(model, model);
    });
    this.modelDropdown.setValue(this.selectedModel);
    this.modelDropdown.onChange((value) => {
      this.selectedModel = value;
    });
  }
  handleSubmit() {
    if (!this.hasApiKey(this.selectedProvider)) {
      new import_obsidian6.Notice(`Please configure ${getProviderDisplayName(this.selectedProvider)} API key in settings first.`);
      return;
    }
    if (!this.sourceText.trim()) {
      new import_obsidian6.Notice("No text to summarize");
      return;
    }
    const options = {
      provider: this.selectedProvider,
      model: this.selectedModel,
      language: this.selectedLanguage,
      outputFormat: this.selectedFormat,
      customPrompt: this.customPrompt
    };
    this.close();
    this.onSubmit(options);
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/main.ts
var MindmapSummarizerPlugin = class extends import_obsidian7.Plugin {
  async onload() {
    await this.loadSettings();
    this.mindmapGenerator = new MindmapGenerator();
    this.addRibbonIcon("brain", "Generate Mindmap", async () => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian7.MarkdownView);
      if (activeView) {
        const content = activeView.editor.getValue();
        if (!content.trim()) {
          new import_obsidian7.Notice("The note is empty");
          return;
        }
        this.openInputModalForInsert(activeView.editor, content);
      } else {
        new import_obsidian7.Notice("Please open a markdown file first");
      }
    });
    this.addCommand({
      id: "generate-mindmap-current",
      name: "Generate mindmap from current note",
      editorCallback: async (editor, view) => {
        const content = editor.getValue();
        if (!content.trim()) {
          new import_obsidian7.Notice("The note is empty");
          return;
        }
        this.openInputModalForInsert(editor, content);
      }
    });
    this.addCommand({
      id: "generate-mindmap-selection",
      name: "Generate mindmap from selection",
      editorCallback: async (editor, view) => {
        const selection = editor.getSelection();
        if (!selection) {
          new import_obsidian7.Notice("Please select some text first");
          return;
        }
        this.openInputModalForInsert(editor, selection);
      }
    });
    this.addCommand({
      id: "generate-mindmap-quick",
      name: "Quick generate mindmap (use saved settings)",
      editorCallback: async (editor, view) => {
        const content = editor.getValue();
        if (!content.trim()) {
          new import_obsidian7.Notice("The note is empty");
          return;
        }
        await this.quickGenerateAndInsert(editor, content);
      }
    });
    this.addCommand({
      id: "generate-mindmap-new-file",
      name: "Generate mindmap to new file",
      editorCallback: async (editor, view) => {
        const content = editor.getValue();
        if (!content.trim()) {
          new import_obsidian7.Notice("The note is empty");
          return;
        }
        this.openInputModalForNewFile(content, view.file);
      }
    });
    this.addSettingTab(new MindmapSummarizerSettingTab(this.app, this));
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  openInputModalForInsert(editor, text) {
    new MindmapInputModal(
      this.app,
      this.settings,
      text,
      async (options) => {
        await this.generateAndInsertMindmap(editor, text, options);
      }
    ).open();
  }
  openInputModalForNewFile(text, sourceFile) {
    new MindmapInputModal(
      this.app,
      this.settings,
      text,
      async (options) => {
        await this.generateMindmapToNewFile(text, sourceFile, options);
      }
    ).open();
  }
  async generateAndInsertMindmap(editor, text, options) {
    const loadingNotice = new import_obsidian7.Notice("Generating mindmap...", 0);
    try {
      const tempSettings = { ...this.settings };
      tempSettings.selectedProvider = options.provider;
      this.setModelForProvider(tempSettings, options.provider, options.model);
      const provider = createProvider(tempSettings);
      const language = options.language;
      const customPrompt = options.customPrompt;
      let finalText = text;
      if (customPrompt) {
        finalText = `${text}

[Additional Instructions: ${customPrompt}]`;
      }
      const result = await provider.summarize(finalText, language);
      loadingNotice.hide();
      let mindmapContent;
      switch (options.outputFormat) {
        case "mermaid":
          mindmapContent = this.mindmapGenerator.generateMermaidMindmap(result);
          break;
        case "markdown":
          mindmapContent = this.mindmapGenerator.generateMarkdownList(result);
          break;
        case "markmap":
          mindmapContent = this.mindmapGenerator.generateMarkmap(result);
          break;
        case "canvas":
          const activeFile = this.app.workspace.getActiveFile();
          await this.createCanvasFile(result, activeFile);
          return;
        default:
          mindmapContent = this.mindmapGenerator.generateMermaidMindmap(result);
      }
      const currentContent = editor.getValue();
      const separator = "\n\n---\n\n## Mindmap Summary\n\n";
      editor.setValue(currentContent + separator + mindmapContent);
      const lastLine = editor.lastLine();
      editor.setCursor({ line: lastLine, ch: 0 });
      new import_obsidian7.Notice("Mindmap inserted!");
    } catch (error) {
      loadingNotice.hide();
      console.error("Mindmap generation error:", error);
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
  }
  async quickGenerateAndInsert(editor, text) {
    const loadingNotice = new import_obsidian7.Notice("Generating mindmap...", 0);
    try {
      const provider = createProvider(this.settings);
      const result = await provider.summarize(text, this.settings.language);
      loadingNotice.hide();
      const mindmapContent = this.mindmapGenerator.generateMermaidMindmap(result);
      const currentContent = editor.getValue();
      const separator = "\n\n---\n\n## Mindmap Summary\n\n";
      editor.setValue(currentContent + separator + mindmapContent);
      const lastLine = editor.lastLine();
      editor.setCursor({ line: lastLine, ch: 0 });
      new import_obsidian7.Notice("Mindmap inserted!");
    } catch (error) {
      loadingNotice.hide();
      console.error("Mindmap generation error:", error);
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
  }
  async generateMindmapToNewFile(text, sourceFile, options) {
    const loadingNotice = new import_obsidian7.Notice("Generating mindmap...", 0);
    try {
      const tempSettings = { ...this.settings };
      tempSettings.selectedProvider = options.provider;
      this.setModelForProvider(tempSettings, options.provider, options.model);
      const provider = createProvider(tempSettings);
      const language = options.language;
      const customPrompt = options.customPrompt;
      let finalText = text;
      if (customPrompt) {
        finalText = `${text}

[Additional Instructions: ${customPrompt}]`;
      }
      const result = await provider.summarize(finalText, language);
      loadingNotice.hide();
      await this.createMindmapNote(result, options.outputFormat, sourceFile);
    } catch (error) {
      loadingNotice.hide();
      console.error("Mindmap generation error:", error);
      new import_obsidian7.Notice(`Error: ${error.message}`);
    }
  }
  setModelForProvider(settings, provider, model) {
    switch (provider) {
      case "openai":
        settings.openaiModel = model;
        break;
      case "anthropic":
        settings.anthropicModel = model;
        break;
      case "gemini":
        settings.geminiModel = model;
        break;
      case "grok":
        settings.grokModel = model;
        break;
    }
  }
  async createCanvasFile(result, sourceFile) {
    var _a;
    const content = this.mindmapGenerator.generateCanvasJson(result);
    let fileName = `${result.title} - Mindmap.canvas`.replace(/[\\/:*?"<>|]/g, "-");
    let folder = "";
    if (sourceFile) {
      folder = ((_a = sourceFile.parent) == null ? void 0 : _a.path) || "";
    }
    const filePath = folder ? `${folder}/${fileName}` : fileName;
    let finalPath = filePath;
    let counter = 1;
    while (this.app.vault.getAbstractFileByPath(finalPath)) {
      const baseName = fileName.replace(".canvas", "");
      finalPath = folder ? `${folder}/${baseName} (${counter}).canvas` : `${baseName} (${counter}).canvas`;
      counter++;
    }
    await this.app.vault.create(finalPath, content);
    const newFile = this.app.vault.getAbstractFileByPath(finalPath);
    if (newFile instanceof import_obsidian7.TFile) {
      await this.app.workspace.getLeaf().openFile(newFile);
    }
    new import_obsidian7.Notice(`Created: ${finalPath}`);
  }
  async createMindmapNote(result, format, sourceFile) {
    var _a;
    let content;
    let fileName;
    switch (format) {
      case "mermaid":
        content = this.mindmapGenerator.generateMermaidMindmap(result);
        fileName = `${result.title} - Mindmap.md`;
        break;
      case "markdown":
        content = this.mindmapGenerator.generateMarkdownList(result);
        fileName = `${result.title} - Summary.md`;
        break;
      case "markmap":
        content = this.mindmapGenerator.generateMarkmap(result);
        fileName = `${result.title} - Markmap.md`;
        break;
      case "canvas":
        content = this.mindmapGenerator.generateCanvasJson(result);
        fileName = `${result.title} - Mindmap.canvas`;
        break;
      default:
        content = this.mindmapGenerator.generateMermaidMindmap(result);
        fileName = `${result.title} - Mindmap.md`;
    }
    fileName = fileName.replace(/[\\/:*?"<>|]/g, "-");
    let folder = "";
    if (sourceFile) {
      folder = ((_a = sourceFile.parent) == null ? void 0 : _a.path) || "";
    }
    const filePath = folder ? `${folder}/${fileName}` : fileName;
    let finalPath = filePath;
    let counter = 1;
    while (this.app.vault.getAbstractFileByPath(finalPath)) {
      const ext = format === "canvas" ? ".canvas" : ".md";
      const baseName = fileName.replace(ext, "");
      finalPath = folder ? `${folder}/${baseName} (${counter})${ext}` : `${baseName} (${counter})${ext}`;
      counter++;
    }
    await this.app.vault.create(finalPath, content);
    const newFile = this.app.vault.getAbstractFileByPath(finalPath);
    if (newFile instanceof import_obsidian7.TFile) {
      await this.app.workspace.getLeaf().openFile(newFile);
    }
    new import_obsidian7.Notice(`Created: ${finalPath}`);
  }
};
